/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */




#include <stm32f103x6.h>
#include "Stm32_F103C6_GPIO.h"
#include "Stm32_F103C6_USART.h"
#include "Stm32_F103C6_SPI.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/* ========= Global Macros ========== */
//#define MCU_Act_As_Master
#define MCU_Act_As_Slave

/* ========= Global variables ========== */
uint16_t data;

/* ========== Prototypes ========= */
 void Clock_Init(void);
 void USART1_CallBack(void);
 void SPI1_CallBack(struct S_IRQ_SRC IRQ_src);

/* =========== Main Program ========== */
int main()
{
	/* Configuration of SS */
	GPIO_PIN_CONFIG_T SS_Config;
	/* Initialization */
	Clock_Init();

	/* Configuration of USART1 */
	USART_Config_t USART1_Config;

	USART1_Config.BaudRate = UART_BaudRate_115200;
	USART1_Config.HwFlowCtl = UART_HwFlowCtl_NONE;
	USART1_Config.IRQ_Enable = UART_IRQ_Enable_RXNEIE;
	USART1_Config.P_IRQ_CallBack = USART1_CallBack;
	USART1_Config.Parity = UART_Parity_NONE;
	USART1_Config.Payload_Length = UART_Payload_Length_8B;
	USART1_Config.StopBits = UART_StopBits_1;
	USART1_Config.USART_Mode = UART_Mode_TX_RX;

	MCAL_UART_Init(USART1, &USART1_Config);
	MCAL_UART_GPIO_Set_Pins(USART1);

	/* Configuration of SPI1 */
	SPI_Config_t SPI1_Config;

	/* Common Configuration */
	SPI1_Config.BaudRate_Prescaler = BAUDERATE_PRESCALER_8;
	SPI1_Config.CLK_Phase = CLK_PHASE_SECOND;
	SPI1_Config.CLK_Polarity = CLK_POLARITY_IDLE_HIGH;
	SPI1_Config.Frame_Format = FRAME_FORMAT_MSB_FIRST;
	SPI1_Config.Frame_Size = FRAME_SIZE_8BIT;
#ifdef MCU_Act_As_Master
	SPI1_Config.Communication_Mode = COMMUNICATION_MODE_2LINE_FULL_DUPLEX;
		SPI1_Config.SPI_Mode = SPI_MODE_MASTER;
		SPI1_Config.IRQ_Enable = IRQ_ENABLE_NONE;
		SPI1_Config.P_IRQ_CallBack = NULL;
		SPI1_Config.NSS = NSS_SW_SSI_SET;

#endif

#ifdef MCU_Act_As_Slave
	SPI1_Config.Communication_Mode= COMMUNICATION_MODE_2LINE_FULL_DUPLEX;
	SPI1_Config.SPI_Mode = SPI_MODE_SLAVE;
	SPI1_Config.IRQ_Enable = IRQ_ENABLE_RXNEIE;
	SPI1_Config.NSS = NSS_HW_SLAVE;
	SPI1_Config.P_IRQ_CallBack = SPI1_CallBack;
#endif



	MCAL_SPI_Init(SPI1, &SPI1_Config);
	MCAL_SPI_GPIO_Set_Pins(SPI1);

#ifdef MCU_Act_As_Master


	/* Configure SS at PA4 by GPIO */
	SS_Config.GPIO_PIN_NUMBER = GPIO_PIN_4;
	SS_Config.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	SS_Config.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHz;

	MCAL_GPIO_Init(GPIOA, &SS_Config);

	/* Force the slave select (High) idle mode */
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif

	/* Loop For Ever */
	while(1){}
}

/* ======== clock Initialize definition ======= */
void Clock_Init(void)
{
	/* Enable clock GPIOA */
	RCC_GPIOA_CLK_EN();

	/* Enable clock GPIOB */
	RCC_GPIOB_CLK_EN();

	/* Enable Clock For AFIO */
	RCC_AFIO_CLK_EN();
}



void USART1_CallBack(void)
{
#ifdef MCU_Act_As_Master
	MCAL_UART_ReceiveData(USART1, &data, USART_disable);
	MCAL_UART_SendData(USART1, &data, USART_enable);

	/* ========= Send Data To SPI1 =========== */

	/* Slave Selection (Low), to listen  */
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);

	MCAL_SPI_TX_RX(SPI1, &data, SPI_enable);

	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif
}

void SPI1_CallBack(struct S_IRQ_SRC IRQ_src)
{
#ifdef MCU_Act_As_Slave
	if(IRQ_src.RXNE)
	{
		data = 0xf;
		MCAL_SPI_TX_RX(SPI1, &data, SPI_disable);

		MCAL_UART_SendData(USART1, &data, USART_enable);
	}
#endif
}
